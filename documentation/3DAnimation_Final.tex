\documentclass{sig-alternate-05-2015}
\usepackage{listings}

\begin{document}


\title{Avalanche Simulation in a Particle System}
\subtitle{As a part of the Master - Module 3D-Animation in the Hochschule Rhein Main
purely written in Python and OpenGL}
%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{2}
\author{
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
Tiras Zemicael\\
       \affaddr{Karl-Blum-Allee 57, 65929 Frankfurt am Main}\\
       \email{Tiras.Zemicael@student.hs-rm.de}
% 2nd. author
\alignauthor
Simon Rininsland\\
       \affaddr{Roseggerstrasse 5, 65187 Wiesbaden}\\
       \email{Simon.Rininsland@student.hs-rm.de}
}


\maketitle
\begin{abstract}
(What did we do. As tiny as possible)\\
- the question(s) you investigated (or purpose), (from Introduction)\\
	- state the purpose very clearly in the first or second sentence.\\
- the experimental design and methods used, (from Methods)\\
	- clearly express the basic design of the study.\\
	- Name or briefly describe the basic methodology used without going into excessive detail-be sure to indicate the key techniques used.\\
- the major findings including key quantitative results, or trends (from Results)\\
	- report those results which answer the questions you were asking\\
	- identify trends, relative change or differences, etc.\\
- a brief summary of your interpetations and conclusions. (from Discussion)\\
	- clearly state the implications of the answers your results gave you.\\
\\
\\
An Avalanche. A natural dreaded force of many snow and ice particles rushing down a Slope, driven by the Gravity. As many as snowflakes and ice particles which are included in an avalanche as good as we can play with them in an Particle System. One of the best examples for dynamicly rendered simulations for Particle Systems a snow Avalanche will be the central Part in our Project.\\
In order also to start just from the basics we decided to not use huge frameworks and start from the OpenGL Scatch. We will just use OpenGL Basics.\\ 
\\

We will solve some Physically based Problems which comes around with the Topic of an Avalanche like:\\
- Particles with seperated masses, driven by a force.\\
- Physically Effects, bouncing Particles and combining ones.\\
and some OpenGL based Problems like: \\
- shadow for every seperated Particle \\
- performance Issues and optimization.\\ 

We have developed a piece of Software, we want to simulate a physic driven avalanche. The Core features are mainly dedicated to understand and solving physical Problems. We created Particles which reacts on physical forces from outside. These happens physically correct. After that we took some work to give the Particles a good-looking view, which should give a better understanding what we try to simulate at the first look. \\

\end{abstract}


\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10010147.10010371.10010352.10010379</concept_id>
<concept_desc>Computing methodologies~Physical simulation</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[300]{Computing methodologies~Physical simulation}




\section{Introduction}
In the current time Simulation for almost everything exist. Simulations are a important part of todays society and is used for everything that can’t be test on a large scale or can’t even be create. The simulations are created to see possible situation or behavior of different thinks, for that the simulations need to be precise. Simulations are for the most parts not only a programming problem but also a problem in the subject the simulations are aiming for. Simulations need to behave the exact same as the real world counterpart, therefore a lot of physics is involved in such a simulation. And one of the highest requested kind of simulations are for weather phenomena. For that kind of problem simulations for every kind of weather phenomena exist. There are simulations for tidal waves, thunderstorms, flood and for our project Avalanche.
\subsection{Project Description}
\subsection{Project Result}
\section{Technology}
\subsection{Python}
\subsection{OpenGL}
\subsection{Other Packages}
\section{Architecture}
Our Program inherits different Classes. The main Architecture can be described as follows:\\
All Objects in the World are described in the Objects class. Now, we have a Terrain and many particles. Both are implemented through the Object Class. A Particle inherits from the Objects Class, but uses some of the functions from the Objects Class. The World Class holds the Modell of our Program. \\
To have a Modell in our Program we need places to hold our Data. We took Numpy to store the position of every Particle in a global Grid-System.\\
Our Architecture must inherit a place to store all Particle Positions and must depict the Terrain. Because we saw fast, we can implement the Terrain Storage in a 2-dimensional Terrain, we decided to use two Arrays to store our Data. \\
\subsection{Object Class}
\subsection{Partcile Class}
\subsection{World Class}
Our World Class stores the main Data in our Program. We have used a direct mapping from the real view World to our Modell. The Terrain has a 128 Unit Width and Length. On the top, we need 2 Units to have an invisible Wall. Regarding these two Unit Rules, we need to have a 130 Units big 3-dimensional Array. Because Numpy is very fast in creating those huge arrays, we used Numpy to create the Array. \\
With:\\
\begin{lstlisting} [language=Python]
self.grid = np.zeros((self.gridResolution, 
self.gridResolution, self.gridResolution),
 dtype=int)
\end{lstlisting}
We create fast a needed Array filled with zeros in Integer Type. We use Integer Types because we only need Integer values in our Array. Why is described later. Because we used -1 to set a Grid as not used, we must fill the array with:\\
\begin{lstlisting} [language=Python]
self.grid.fill(-1)
\end{lstlisting}
with -1. \\
This creating and filling 3D Array with Numpy used less than a tenth of a second on a i7 PC. Creating this array and filling with -1 with conventional Python tools would spent more than 20 Seconds. \\
In nearly the same way we can create our terrain Map, with the difference of creating just a 2-dimensional Array with Numpy with Float Values in it, with: \\
\begin{lstlisting} [language=Python]
self.terrainHeightMap = np.zeros((
self.gridResolution, self.gridResolution), 
dtype=float)
\end{lstlisting}
Our World is now ready to hold all our needed Data for further calculations.\\
\subsubsection{Grid System}
We recognized very soon, we need a Grid system to not check the collision against all Particles. With more than 100 Particles the Program already gets unsmooth with less than 10 Frames per Second. The Idea was to only check Particle Collision between Particles which are in the same Vortex. A collision between 2 Particles which are in totally different Areas in the Map is not possible.\\
In the world - Class we already defined a grid for our world. Because the position of a single Particle is always written relative to zero and spawns between -64 to +64 we need to do a: \\
\begin{lstlisting} [language=Python]
x = int(round(self.position[0])) 
+ world.worldSize
y = int(round(self.position[1]))
+ world.worldSize
z = int(round(self.position[2]))
+ world.worldSize
\end{lstlisting}
for every Particle Position to map it on our Grid System. We use this x, y, z Indices for selecting the Vortex in our 3-dimensional Grid array. Furthermore, we check the value in the selected Vortex. If it’s -1 we can simply write the Index of the Particle. If there is already another Index from a Particle, we need to check if there is a Collision. How this works is described in another Topic. If there is a Collision, we need to Call the Collision Reaction from both or more Particles in the Grid. Afterwards we need to add our Index to the other Indices in the Grid. Of course, we must remove our Index from the Vortex before, after entering a new one. \\
To have fast remove and append Array operations we use Numpy here too. \\
\subsubsection{Terrain Height}
Our Terrain Height Map works slightly different like the Grid System. Because the Terrain Map Array is depicting only the X and Z Axes, we only need to take the X and Z Value of each Particle and do the same like above: \\
\begin{lstlisting} [language=Python]
x = int(round(self.position[0]))
+ world.worldSize
z = int(round(self.position[2]))
+ world.worldSize
\end{lstlisting}
We give a look in the Terrain Map with the Indices of x and z and check the value with the height of the Particle. We combined this “could be a collision” and recognize a real Collision in this case. The detailed check collision with Terrain is described later. \\
\section{Collision}
\subsection{Particle Collision}
\subsection{Terrain Collision}
\section{Conclusion and Outlook}


\bibliographystyle{abbrv}
\bibliography{sigproc} 

\end{document}
